name: Performance Benchmark

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      devices:
        description: 'Devices to benchmark (comma-separated: CPU only on GitHub runners)'
        required: false
        default: 'CPU'
        type: string
      iterations:
        description: 'Number of iterations per device'
        required: false
        default: '3'
        type: number
      model_name:
        description: 'Model to use for benchmarking'
        required: false
        default: 'FluidInference/qwen3-0.6b-int4-ov-npu'
        type: string
      compare_with_baseline:
        description: 'Compare with baseline performance'
        required: false
        default: true
        type: boolean
        
permissions:
  pull-requests: write
  issues: write

env:
  OPENVINO_VERSION: "2025.2.0.0"

jobs:
  benchmark:
    name: Performance Benchmark
    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Cache Model
      uses: actions/cache@v4
      with:
        path: ./Models
        key: model-${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}-v1
        restore-keys: |
          model-${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}-

    - name: Cache Baseline Performance Data
      if: inputs.compare_with_baseline
      uses: actions/cache@v4
      with:
        path: ./baseline-performance
        key: baseline-performance-win-x64-v1
        restore-keys: |
          baseline-performance-win-x64-

    - name: Restore dependencies
      run: dotnet restore OpenVINO.NET.sln

    - name: Cache OpenVINO Runtime
      id: cache-openvino-windows
      uses: actions/cache@v4
      with:
        path: build/native/openvino_genai_windows_${{ env.OPENVINO_VERSION }}_x86_64
        key: openvino-runtime-windows-${{ env.OPENVINO_VERSION }}

    - name: Download OpenVINO Runtime
      if: steps.cache-openvino-windows.outputs.cache-hit != 'true'
      shell: pwsh
      run: |
        Write-Host "Downloading OpenVINO GenAI Runtime for Windows..."
        
        # Try multiple potential URLs for robustness
        $urls = @(
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/windows/openvino_genai_windows_${{ env.OPENVINO_VERSION }}_x86_64.zip",
          "https://storage.openvinotoolkit.org/repositories/openvino_genai/packages/2025.2/windows/openvino_genai_runtime_windows_${{ env.OPENVINO_VERSION }}_x86_64.zip"
        )
        
        $downloaded = $false
        $output = "openvino_genai_runtime.zip"
        
        foreach ($url in $urls) {
          Write-Host "Trying: $url"
          try {
            Invoke-WebRequest -Uri $url -OutFile $output -UserAgent "OpenVINO.NET/1.0"
            
            # Verify the downloaded file is a valid ZIP
            if (Test-Path $output -PathType Leaf) {
              $fileInfo = Get-Item $output
              if ($fileInfo.Length -gt 1MB) {
                Write-Host "âœ“ Successfully downloaded from: $url"
                $downloaded = $true
                break
              } else {
                Write-Host "âœ— Downloaded file too small: $($fileInfo.Length) bytes"
                Remove-Item $output -ErrorAction SilentlyContinue
              }
            }
          } catch {
            Write-Host "âœ— Failed to download from: $url - $($_.Exception.Message)"
            Remove-Item $output -ErrorAction SilentlyContinue
          }
        }
        
        if (-not $downloaded) {
          Write-Host "âŒ Failed to download OpenVINO runtime from any URL"
          exit 1
        }
        
        Write-Host "Extracting runtime..."
        Expand-Archive -Path $output -DestinationPath "temp_extract" -Force
        
        # Find the extracted directory (handle different naming conventions)
        $extractedDirs = Get-ChildItem -Path "temp_extract" -Directory | Where-Object { $_.Name -like "openvino_genai*" }
        
        if ($extractedDirs.Count -eq 0) {
          Write-Host "âŒ Could not find extracted OpenVINO directory"
          Get-ChildItem -Path "temp_extract" | Format-Table
          exit 1
        }
        
        $extractedDir = $extractedDirs[0].FullName
        Write-Host "Found extracted directory: $($extractedDirs[0].Name)"
        
        # Create target directory and copy files
        New-Item -Path "build/native/runtimes/win-x64/native" -ItemType Directory -Force
        
        # Try different potential library paths
        if (Test-Path "$extractedDir/runtime/bin") {
          Copy-Item -Path "$extractedDir/runtime/bin/*" -Destination "build/native/runtimes/win-x64/native/" -Recurse -Force
        } elseif (Test-Path "$extractedDir/bin") {
          Copy-Item -Path "$extractedDir/bin/*" -Destination "build/native/runtimes/win-x64/native/" -Recurse -Force
        } else {
          Write-Host "âŒ Could not find binary directory in extracted folder"
          Get-ChildItem -Path $extractedDir | Format-Table
          exit 1
        }
        
        Remove-Item -Path $output, "temp_extract" -Recurse -Force
        Write-Host "âœ“ OpenVINO runtime setup completed"

    - name: Build solution
      run: dotnet build OpenVINO.NET.sln --configuration Release

    - name: Download Benchmark Model
      working-directory: ./samples/QuickDemo
      shell: pwsh
      run: |
        New-Item -ItemType Directory -Path "Models" -Force
        Set-Location Models
        
        # Use model name from input or default
        $MODEL_NAME = "${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}"
        $MODEL_DIR = $MODEL_NAME.Split('/')[1]
        
        if ((-not (Test-Path $MODEL_DIR)) -or (-not (Test-Path "$MODEL_DIR/openvino_model.xml"))) {
          Write-Host "Downloading model: $MODEL_NAME"
          
          New-Item -ItemType Directory -Path $MODEL_DIR -Force
          Set-Location $MODEL_DIR
          
          # Download key files
          $files = @("openvino_model.xml", "openvino_model.bin", "openvino_tokenizer.xml", "openvino_tokenizer.bin", "openvino_detokenizer.xml", "openvino_detokenizer.bin", "config.json", "generation_config.json")
          
          foreach ($file in $files) {
            Write-Host "Downloading $file..."
            try {
              Invoke-WebRequest -Uri "https://huggingface.co/$MODEL_NAME/resolve/main/$file" -OutFile $file -UserAgent "OpenVINO.NET/1.0"
            } catch {
              Write-Host "Warning: Failed to download $file (may be optional)"
            }
          }
          
          Set-Location ..
          Write-Host "âœ“ Model download completed"
        } else {
          Write-Host "âœ“ Model already cached"
        }

    - name: Set Model Path Environment
      shell: pwsh
      run: |
        $MODEL_NAME = "${{ inputs.model_name || 'FluidInference/qwen3-0.6b-int4-ov-npu' }}"
        $MODEL_DIR = $MODEL_NAME.Split('/')[1]
        $MODEL_PATH = "$(Get-Location)/samples/QuickDemo/Models/$MODEL_DIR"
        "QUICKDEMO_MODEL_PATH=$MODEL_PATH" | Out-File -FilePath $env:GITHUB_ENV -Append

    - name: Run Performance Benchmark
      working-directory: ./samples/QuickDemo
      shell: pwsh
      run: |
        # Note: GitHub hosted runners only have CPU available, no GPU/NPU
        $devices = "${{ inputs.devices || 'CPU' }}" -split ','
        $iterations = [int]"${{ inputs.iterations || 3 }}"
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $benchmarkResults = @()
        
        Write-Host "Performance Benchmark - $timestamp"
        Write-Host "Devices: $($devices -join ', ')"
        Write-Host "Iterations per device: $iterations"
        Write-Host "Platform: win-x64"
        Write-Host ""
        
        foreach ($device in $devices) {
          $device = $device.Trim()
          Write-Host "Benchmarking device: $device"
          Write-Host "================================"
          
          $deviceResults = @{
            Device = $device
            Platform = "win-x64"
            Timestamp = $timestamp
            Iterations = @()
            Success = $false
            ErrorMessage = ""
          }
          
          for ($i = 1; $i -le $iterations; $i++) {
            Write-Host "Iteration $i/$iterations..."
            
            try {
              $startTime = Get-Date
              $output = dotnet run --configuration Release -- --device $device 2>&1
              $endTime = Get-Date
              $exitCode = $LASTEXITCODE
              
              # Debug: Show full output and exit code
              Write-Host "  Debug - Exit code: $exitCode"
              Write-Host "  Debug - Full output:"
              Write-Host "  $output"
              Write-Host "  ---"
              
              if ($exitCode -eq 0) {
                # Parse performance metrics
                $tpsMatch = [regex]::Match($output, 'Performance:\s+(\d+(?:\.\d+)?)\s+tokens/sec')
                $latencyMatch = [regex]::Match($output, 'First token:\s+(\d+)ms')
                
                # Debug: Show what we're trying to parse
                Write-Host "  Debug - Output to parse:"
                Write-Host "  $output"
                Write-Host "  TPS Match: $($tpsMatch.Success), Value: $($tpsMatch.Groups[1].Value)"
                Write-Host "  Latency Match: $($latencyMatch.Success), Value: $($latencyMatch.Groups[1].Value)"
                
                $iterationResult = @{
                  Iteration = $i
                  Success = $true
                  TokensPerSecond = if ($tpsMatch.Success) { [double]$tpsMatch.Groups[1].Value } else { 0 }
                  FirstTokenLatencyMs = if ($latencyMatch.Success) { [int]$latencyMatch.Groups[1].Value } else { 0 }
                  TotalTimeMs = ($endTime - $startTime).TotalMilliseconds
                  MemoryUsageMB = 0
                }
                
                $deviceResults.Iterations += $iterationResult
                $deviceResults.Success = $true
                
                Write-Host "  âœ“ TPS: $($iterationResult.TokensPerSecond), Latency: $($iterationResult.FirstTokenLatencyMs)ms"
              } else {
                Write-Host "  âœ— Failed with exit code: $exitCode"
                Write-Host "  Output: $output"
                $deviceResults.ErrorMessage = "Exit code: $exitCode, Output: $output"
                break
              }
            } catch {
              Write-Host "  âœ— Exception: $($_.Exception.Message)"
              $deviceResults.ErrorMessage = $_.Exception.Message
              break
            }
          }
          
          # Calculate averages for successful runs
          if ($deviceResults.Success -and $deviceResults.Iterations.Count -gt 0) {
            $successfulIterations = $deviceResults.Iterations | Where-Object { $_.Success }
            
            $deviceResults.AverageTokensPerSecond = ($successfulIterations | Measure-Object -Property TokensPerSecond -Average).Average
            $deviceResults.AverageFirstTokenLatencyMs = ($successfulIterations | Measure-Object -Property FirstTokenLatencyMs -Average).Average
            $deviceResults.AverageTotalTimeMs = ($successfulIterations | Measure-Object -Property TotalTimeMs -Average).Average
            $deviceResults.MaxMemoryUsageMB = ($successfulIterations | Measure-Object -Property MemoryUsageMB -Maximum).Maximum
            
            Write-Host "  Average TPS: $($deviceResults.AverageTokensPerSecond.ToString('F2'))"
            Write-Host "  Average Latency: $($deviceResults.AverageFirstTokenLatencyMs.ToString('F0'))ms"
          }
          
          $benchmarkResults += $deviceResults
          Write-Host ""
        }
        
        # Save detailed results to JSON
        $resultFile = "benchmark-results-win-x64-$timestamp.json"
        $benchmarkResults | ConvertTo-Json -Depth 10 | Out-File -FilePath $resultFile
        
        # Create summary table
        $summaryFile = "benchmark-summary-win-x64-$timestamp.txt"
        "Performance Benchmark Summary - win-x64" | Out-File -FilePath $summaryFile
        "Generated: $timestamp" | Out-File -FilePath $summaryFile -Append
        "" | Out-File -FilePath $summaryFile -Append
        "Device       | Status | Avg TPS | Avg Latency | Iterations" | Out-File -FilePath $summaryFile -Append
        "------------ | ------ | ------- | ----------- | ----------" | Out-File -FilePath $summaryFile -Append
        
        foreach ($result in $benchmarkResults) {
          $status = if ($result.Success) { "âœ“" } else { "âœ—" }
          $avgTps = if ($result.Success) { $result.AverageTokensPerSecond.ToString("F1") } else { "N/A" }
          $avgLatency = if ($result.Success) { $result.AverageFirstTokenLatencyMs.ToString("F0") + "ms" } else { "N/A" }
          $iterCount = if ($result.Success) { $result.Iterations.Count } else { "0" }
          
          "$($result.Device.PadRight(12)) | $($status.PadRight(6)) | $($avgTps.PadRight(7)) | $($avgLatency.PadRight(11)) | $iterCount" | Out-File -FilePath $summaryFile -Append
        }
        
        "" | Out-File -FilePath $summaryFile -Append
        
        # Add error details for failed devices
        $failedDevices = $benchmarkResults | Where-Object { -not $_.Success }
        if ($failedDevices) {
          "Failed Devices:" | Out-File -FilePath $summaryFile -Append
          foreach ($failed in $failedDevices) {
            "â€¢ $($failed.Device): $($failed.ErrorMessage)" | Out-File -FilePath $summaryFile -Append
          }
        }
        
        Write-Host "Benchmark Results Summary:"
        Get-Content $summaryFile
        
        # Set environment variables for comparison step
        $bestDevice = $benchmarkResults | Where-Object { $_.Success } | Sort-Object -Property AverageTokensPerSecond -Descending | Select-Object -First 1
        if ($bestDevice) {
          "BEST_DEVICE=$($bestDevice.Device)" | Out-File -FilePath $env:GITHUB_ENV -Append
          "BEST_TPS=$($bestDevice.AverageTokensPerSecond.ToString('F2'))" | Out-File -FilePath $env:GITHUB_ENV -Append
        }

    - name: Compare with Baseline
      if: inputs.compare_with_baseline
      shell: pwsh
      run: |
        $baselineDir = "baseline-performance"
        $currentResults = "benchmark-results-win-x64-*.json"
        
        if (-not (Test-Path $baselineDir)) {
          New-Item -ItemType Directory -Path $baselineDir -Force
          Write-Host "No baseline data found. Current results will be used as baseline."
          Copy-Item $currentResults $baselineDir/
        } else {
          Write-Host "Comparing with baseline performance..."
          
          # Load current and baseline results
          $currentFile = Get-ChildItem $currentResults | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          $baselineFile = Get-ChildItem "$baselineDir/benchmark-results-win-x64-*.json" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          
          if ($currentFile -and $baselineFile) {
            $current = Get-Content $currentFile.FullName | ConvertFrom-Json
            $baseline = Get-Content $baselineFile.FullName | ConvertFrom-Json
            
            Write-Host "Performance Comparison vs Baseline:"
            Write-Host "===================================="
            
            foreach ($currentDevice in $current) {
              if ($currentDevice.Success) {
                $baselineDevice = $baseline | Where-Object { $_.Device -eq $currentDevice.Device -and $_.Success }
                
                if ($baselineDevice) {
                  $tpsChange = (($currentDevice.AverageTokensPerSecond - $baselineDevice.AverageTokensPerSecond) / $baselineDevice.AverageTokensPerSecond) * 100
                  $latencyChange = (($currentDevice.AverageFirstTokenLatencyMs - $baselineDevice.AverageFirstTokenLatencyMs) / $baselineDevice.AverageFirstTokenLatencyMs) * 100
                  
                  $tpsSymbol = if ($tpsChange -gt 5) { "ðŸ“ˆ" } elseif ($tpsChange -lt -5) { "ðŸ“‰" } else { "âž¡ï¸" }
                  $latencySymbol = if ($latencyChange -lt -5) { "ðŸ“ˆ" } elseif ($latencyChange -gt 5) { "ðŸ“‰" } else { "âž¡ï¸" }
                  
                  Write-Host "$($currentDevice.Device):"
                  Write-Host "  TPS: $($baselineDevice.AverageTokensPerSecond.ToString('F1')) â†’ $($currentDevice.AverageTokensPerSecond.ToString('F1')) ($($tpsChange.ToString('F1'))%) $tpsSymbol"
                  Write-Host "  Latency: $($baselineDevice.AverageFirstTokenLatencyMs.ToString('F0'))ms â†’ $($currentDevice.AverageFirstTokenLatencyMs.ToString('F0'))ms ($($latencyChange.ToString('F1'))%) $latencySymbol"
                } else {
                  Write-Host "$($currentDevice.Device): No baseline data available"
                }
              }
            }
            
            # Update baseline if current performance is significantly better
            $shouldUpdateBaseline = $false
            foreach ($currentDevice in $current) {
              if ($currentDevice.Success) {
                $baselineDevice = $baseline | Where-Object { $_.Device -eq $currentDevice.Device -and $_.Success }
                if ($baselineDevice -and $currentDevice.AverageTokensPerSecond -gt ($baselineDevice.AverageTokensPerSecond * 1.05)) {
                  $shouldUpdateBaseline = $true
                  break
                }
              }
            }
            
            if ($shouldUpdateBaseline) {
              Write-Host ""
              Write-Host "ðŸ“Š Performance improvement detected. Updating baseline..."
              Copy-Item $currentFile.FullName $baselineDir/
            }
          }
        }

    - name: Upload Benchmark Results
      uses: actions/upload-artifact@v4
      with:
        name: benchmark-results-win-x64
        path: |
          ./samples/QuickDemo/benchmark-results-*.json
          ./samples/QuickDemo/benchmark-summary-*.txt

    - name: Create Performance Summary
      shell: pwsh
      run: |
        $summaryFile = Get-ChildItem "./samples/QuickDemo/benchmark-summary-win-x64-*.txt" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
        
        if ($summaryFile) {
          Write-Host "## Performance Benchmark Results (Windows)" > performance-summary.md
          Write-Host "" >> performance-summary.md
          Write-Host "**Best Device:** $env:BEST_DEVICE ($env:BEST_TPS TPS)" >> performance-summary.md
          Write-Host "" >> performance-summary.md
          Write-Host "### Detailed Results" >> performance-summary.md
          Write-Host "``````" >> performance-summary.md
          Get-Content $summaryFile.FullName >> performance-summary.md
          Write-Host "``````" >> performance-summary.md
          
          Write-Host ""
          Get-Content performance-summary.md
        }

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          if (fs.existsSync('performance-summary.md')) {
            const summary = fs.readFileSync('performance-summary.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          }
